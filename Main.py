import pandas as pd
import numpy as np
import os
import keras
import scipy
import matplotlib as plt
from keras.layers import Dense, GlobalAveragePooling2D
from keras.applications import ResNet50
#from keras.preprocessing import image
from PIL import Image
from keras.applications.resnet50 import preprocess_input
from keras.preprocessing.image import ImageDataGenerator
from keras.preprocessing.image import img_to_array
from keras.models import Model
from keras.optimizers import Adam
import tensorflow as tf
from tensorflow.python.client import device_lib
from keras.preprocessing.image import load_img
from scipy.spatial.transform import Rotation as R

# print(device_lib.list_local_devices())
def loadImages(numImages):
    images = np.zeros((numImages,256,341,3))
    xyz = np.zeros((numImages,3))
    q = np.zeros((numImages,4))
    # load the image
    for i in range(numImages):
        # Load in image
        mainFilePath = "./7scenes/chess/seq-01/frame"
        imageFileName = "{}-{}.color.png".format(mainFilePath,str(i).zfill(6))
        img = load_img(imageFileName)
        img = img.resize((341,256),Image.ANTIALIAS)
        images[i,:,:,:] = img_to_array(img)

        # Load in pose data
        poseFileName = "{}-{}.pose.txt".format(mainFilePath,str(i).zfill(6))
        file_handle = open(poseFileName, 'r')
        # Read in all the lines of your file into a list of lines
        lines_list = file_handle.readlines()
        # Do a double-nested list comprehension to store as a Homogeneous Transform matrix
        homogeneousTransformList = [[float(val) for val in line.split()] for line in lines_list[0:]]
        homogeneousTransform = np.zeros((4,4))

        for j in range(4):
            homogeneousTransform[j,:] = homogeneousTransformList[j]

        # Extract rotation from homogeneous Transform
        r = R.from_dcm(homogeneousTransform[0:3,0:3])
        q[i,:] = r.as_quat()
        # Extract xyz from homogeneous Transform
        xyz[i,:] = homogeneousTransform[0:3,3]

        file_handle.close()
    return images,xyz,q

# Following 2 functions copied from https://jkjung-avt.github.io/keras-image-cropping/
def random_crop(img, random_crop_size):
    # Note: image_data_format is 'channel_last'
    assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx), :]

# This function has been modified from source to remove references to yield
def crop_generator(batches, crop_length):
    """Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator.
    """
    batch_crops = np.zeros((batches.shape[0], crop_length, crop_length, 3))
    for i in range(batches.shape[0]):
        batch_crops[i] = random_crop(batches[i], (crop_length, crop_length))
    return batch_crops


x_train, y_xyz_train, y_q_train = loadImages(1000)
print("x_train shape: ",x_train.shape)
print("y_xyz_train shape: ",y_xyz_train.shape)
print("y_q_train shape: ",y_q_train.shape)
base_model = ResNet50(weights='imagenet', include_top=False)

x = base_model.output
x = GlobalAveragePooling2D()(x)  # **** Assuming 2D, with no arguments required
x = Dense(1024, activation='relu', name='fc1')(x)  # **** Assuming relu
xyz = Dense(3, activation='softmax', name='xyz')(x)  # **** Assuming softmax is the correct activation here
q = Dense(4, activation='softmax', name='q')(x)  # **** Assuming softmax (rho/theta/phi) and quaternians

global_pose_network = Model(inputs=base_model.input, outputs=[xyz, q])

global_pose_network.compile(optimizer='Adam',loss='mean_squared_error')
#global_pose_network.summary()

train_datagen = ImageDataGenerator(featurewise_center=True)
# compute quantities required for featurewise normalization
# (std, mean, and principal components if ZCA whitening is applied)
train_datagen.fit(x_train)
train_crops = crop_generator(x_train, 224)

global_pose_network.fit(x=train_crops, y={'xyz' : y_xyz_train, 'q': y_q_train}, batch_size=32, verbose=1, shuffle=False, epochs=1)


print("Finished Successfully")